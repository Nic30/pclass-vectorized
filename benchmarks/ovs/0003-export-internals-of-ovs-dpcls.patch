From a6d12f9f5eb5368fe9fd4835584e2458b1355382 Mon Sep 17 00:00:00 2001
From: Nic30 <nic30@seznam.cz>
Date: Thu, 22 Aug 2019 17:38:46 +0200
Subject: [PATCH 3/3] export internals of ovs dpcls

---
 lib/dp-packet.h   |   4 +-
 lib/dpif-netdev.c | 175 ++++------------------------------------------
 lib/dpif-netdev.h | 169 +++++++++++++++++++++++++++++++++++++++++++-
 lib/hash.h        |   2 +-
 4 files changed, 183 insertions(+), 167 deletions(-)

diff --git a/lib/dp-packet.h b/lib/dp-packet.h
index ba91e5891..621c4a214 100644
--- a/lib/dp-packet.h
+++ b/lib/dp-packet.h
@@ -367,7 +367,7 @@ dp_packet_get_tcp_payload(const struct dp_packet *b)
     size_t l4_size = dp_packet_l4_size(b);
 
     if (OVS_LIKELY(l4_size >= TCP_HEADER_LEN)) {
-        struct tcp_header *tcp = dp_packet_l4(b);
+        struct tcp_header *tcp = (struct tcp_header *)dp_packet_l4(b);
         int tcp_len = TCP_OFFSET(tcp->tcp_ctl) * 4;
 
         if (OVS_LIKELY(tcp_len >= TCP_HEADER_LEN && tcp_len <= l4_size)) {
@@ -755,7 +755,7 @@ static inline void
 dp_packet_batch_refill(struct dp_packet_batch *batch,
                        struct dp_packet *packet, size_t idx)
 {
-    dp_packet_batch_add__(batch, packet, MIN(NETDEV_MAX_BURST, idx + 1));
+    dp_packet_batch_add__(batch, packet, MIN((int)NETDEV_MAX_BURST, idx + 1));
 }
 
 static inline void
diff --git a/lib/dpif-netdev.c b/lib/dpif-netdev.c
index dc1f69e05..ea291232e 100644
--- a/lib/dpif-netdev.c
+++ b/lib/dpif-netdev.c
@@ -121,14 +121,7 @@ static struct odp_support dp_netdev_support = {
     .ct_orig_tuple6 = true,
 };
 
-/* Stores a miniflow with inline values */
 
-struct netdev_flow_key {
-    uint32_t hash;       /* Hash function differs for different users. */
-    uint32_t len;        /* Length of the following miniflow (incl. map). */
-    struct miniflow mf;
-    uint64_t buf[FLOW_MAX_PACKET_U64S];
-};
 
 /* EMC cache and SMC cache compose the datapath flow cache (DFC)
  *
@@ -229,31 +222,6 @@ struct dfc_cache {
  * and used during rxq to pmd assignment. */
 #define PMD_RXQ_INTERVAL_MAX 6
 
-struct dpcls {
-    struct cmap_node node;      /* Within dp_netdev_pmd_thread.classifiers */
-    odp_port_t in_port;
-    struct cmap subtables_map;
-    struct pvector subtables;
-};
-
-/* A rule to be inserted to the classifier. */
-struct dpcls_rule {
-    struct cmap_node cmap_node;   /* Within struct dpcls_subtable 'rules'. */
-    struct netdev_flow_key *mask; /* Subtable's mask. */
-    struct netdev_flow_key flow;  /* Matching key. */
-    /* 'flow' must be the last field, additional space is allocated here. */
-};
-
-static void dpcls_init(struct dpcls *);
-static void dpcls_destroy(struct dpcls *);
-static void dpcls_sort_subtable_vector(struct dpcls *);
-static void dpcls_insert(struct dpcls *, struct dpcls_rule *,
-                         const struct netdev_flow_key *mask);
-static void dpcls_remove(struct dpcls *, struct dpcls_rule *);
-static bool dpcls_lookup(struct dpcls *cls,
-                         const struct netdev_flow_key *keys[],
-                         struct dpcls_rule **rules, size_t cnt,
-                         int *num_lookups_p);
 static bool dpcls_rule_matches_key(const struct dpcls_rule *rule,
                             const struct netdev_flow_key *target);
 /* Set of supported meter flags */
@@ -455,113 +423,6 @@ struct dp_netdev_port {
     char *rxq_affinity_list;    /* Requested affinity of rx queues. */
 };
 
-/* Contained by struct dp_netdev_flow's 'stats' member.  */
-struct dp_netdev_flow_stats {
-    atomic_llong used;             /* Last used time, in monotonic msecs. */
-    atomic_ullong packet_count;    /* Number of packets matched. */
-    atomic_ullong byte_count;      /* Number of bytes matched. */
-    atomic_uint16_t tcp_flags;     /* Bitwise-OR of seen tcp_flags values. */
-};
-
-/* A flow in 'dp_netdev_pmd_thread's 'flow_table'.
- *
- *
- * Thread-safety
- * =============
- *
- * Except near the beginning or ending of its lifespan, rule 'rule' belongs to
- * its pmd thread's classifier.  The text below calls this classifier 'cls'.
- *
- * Motivation
- * ----------
- *
- * The thread safety rules described here for "struct dp_netdev_flow" are
- * motivated by two goals:
- *
- *    - Prevent threads that read members of "struct dp_netdev_flow" from
- *      reading bad data due to changes by some thread concurrently modifying
- *      those members.
- *
- *    - Prevent two threads making changes to members of a given "struct
- *      dp_netdev_flow" from interfering with each other.
- *
- *
- * Rules
- * -----
- *
- * A flow 'flow' may be accessed without a risk of being freed during an RCU
- * grace period.  Code that needs to hold onto a flow for a while
- * should try incrementing 'flow->ref_cnt' with dp_netdev_flow_ref().
- *
- * 'flow->ref_cnt' protects 'flow' from being freed.  It doesn't protect the
- * flow from being deleted from 'cls' and it doesn't protect members of 'flow'
- * from modification.
- *
- * Some members, marked 'const', are immutable.  Accessing other members
- * requires synchronization, as noted in more detail below.
- */
-struct dp_netdev_flow {
-    const struct flow flow;      /* Unmasked flow that created this entry. */
-    /* Hash table index by unmasked flow. */
-    const struct cmap_node node; /* In owning dp_netdev_pmd_thread's */
-                                 /* 'flow_table'. */
-    const struct cmap_node mark_node; /* In owning flow_mark's mark_to_flow */
-    const ovs_u128 ufid;         /* Unique flow identifier. */
-    const ovs_u128 mega_ufid;    /* Unique mega flow identifier. */
-    const unsigned pmd_id;       /* The 'core_id' of pmd thread owning this */
-                                 /* flow. */
-
-    /* Number of references.
-     * The classifier owns one reference.
-     * Any thread trying to keep a rule from being freed should hold its own
-     * reference. */
-    struct ovs_refcount ref_cnt;
-
-    bool dead;
-    uint32_t mark;               /* Unique flow mark assigned to a flow */
-
-    /* Statistics. */
-    struct dp_netdev_flow_stats stats;
-
-    /* Actions. */
-    OVSRCU_TYPE(struct dp_netdev_actions *) actions;
-
-    /* While processing a group of input packets, the datapath uses the next
-     * member to store a pointer to the output batch for the flow.  It is
-     * reset after the batch has been sent out (See dp_netdev_queue_batches(),
-     * packet_batch_per_flow_init() and packet_batch_per_flow_execute()). */
-    struct packet_batch_per_flow *batch;
-
-    /* Packet classification. */
-    struct dpcls_rule cr;        /* In owning dp_netdev's 'cls'. */
-    /* 'cr' must be the last member. */
-};
-
-static void dp_netdev_flow_unref(struct dp_netdev_flow *);
-static bool dp_netdev_flow_ref(struct dp_netdev_flow *);
-static int dpif_netdev_flow_from_nlattrs(const struct nlattr *, uint32_t,
-                                         struct flow *, bool);
-
-/* A set of datapath actions within a "struct dp_netdev_flow".
- *
- *
- * Thread-safety
- * =============
- *
- * A struct dp_netdev_actions 'actions' is protected with RCU. */
-struct dp_netdev_actions {
-    /* These members are immutable: they do not change during the struct's
-     * lifetime.  */
-    unsigned int size;          /* Size of 'actions', in bytes. */
-    struct nlattr actions[];    /* Sequence of OVS_ACTION_ATTR_* attributes. */
-};
-
-struct dp_netdev_actions *dp_netdev_actions_create(const struct nlattr *,
-                                                   size_t);
-struct dp_netdev_actions *dp_netdev_flow_get_actions(
-    const struct dp_netdev_flow *);
-static void dp_netdev_actions_free(struct dp_netdev_actions *);
-
 struct polled_queue {
     struct dp_netdev_rxq *rxq;
     odp_port_t port_no;
@@ -2011,7 +1872,7 @@ dp_netdev_flow_free(struct dp_netdev_flow *flow)
     free(flow);
 }
 
-static void dp_netdev_flow_unref(struct dp_netdev_flow *flow)
+void dp_netdev_flow_unref(struct dp_netdev_flow *flow)
 {
     if (ovs_refcount_unref_relaxed(&flow->ref_cnt) == 1) {
         ovsrcu_postpone(dp_netdev_flow_free, flow);
@@ -2058,9 +1919,6 @@ dp_netdev_pmd_find_dpcls(struct dp_netdev_pmd_thread *pmd,
     return cls;
 }
 
-#define MAX_FLOW_MARK       (UINT32_MAX - 1)
-#define INVALID_FLOW_MARK   (UINT32_MAX)
-
 struct megaflow_to_mark_data {
     const struct cmap_node node;
     ovs_u128 mega_ufid;
@@ -2597,7 +2455,7 @@ dp_netdev_flow_cast(const struct dpcls_rule *cr)
     return cr ? CONTAINER_OF(cr, struct dp_netdev_flow, cr) : NULL;
 }
 
-static bool dp_netdev_flow_ref(struct dp_netdev_flow *flow)
+bool dp_netdev_flow_ref(struct dp_netdev_flow *flow)
 {
     return ovs_refcount_try_ref_rcu(&flow->ref_cnt);
 }
@@ -2649,7 +2507,7 @@ netdev_flow_key_clone(struct netdev_flow_key *dst,
 }
 
 /* Initialize a netdev_flow_key 'mask' from 'match'. */
-static inline void
+void
 netdev_flow_mask_init(struct netdev_flow_key *mask,
                       const struct match *match)
 {
@@ -2685,7 +2543,7 @@ netdev_flow_mask_init(struct netdev_flow_key *mask,
 }
 
 /* Initializes 'dst' as a copy of 'flow' masked with 'mask'. */
-static inline void
+void
 netdev_flow_key_init_masked(struct netdev_flow_key *dst,
                             const struct flow *flow,
                             const struct netdev_flow_key *mask)
@@ -3061,7 +2919,7 @@ dpif_netdev_mask_from_nlattrs(const struct nlattr *key, uint32_t key_len,
     return 0;
 }
 
-static int
+int
 dpif_netdev_flow_from_nlattrs(const struct nlattr *key, uint32_t key_len,
                               struct flow *flow, bool probe)
 {
@@ -3144,7 +3002,7 @@ out:
     return error;
 }
 
-static void
+void
 dp_netdev_get_mega_ufid(const struct match *match, ovs_u128 *mega_ufid)
 {
     struct flow masked_flow;
@@ -3910,7 +3768,7 @@ dp_netdev_flow_get_actions(const struct dp_netdev_flow *flow)
     return ovsrcu_get(struct dp_netdev_actions *, &flow->actions);
 }
 
-static void
+void
 dp_netdev_actions_free(struct dp_netdev_actions *actions)
 {
     free(actions);
@@ -5717,13 +5575,6 @@ dpif_netdev_packet_get_rss_hash(struct dp_packet *packet,
     return hash;
 }
 
-struct packet_batch_per_flow {
-    unsigned int byte_count;
-    uint16_t tcp_flags;
-    struct dp_netdev_flow *flow;
-
-    struct dp_packet_batch array;
-};
 
 static inline void
 packet_batch_per_flow_update(struct packet_batch_per_flow *batch,
@@ -6966,7 +6817,7 @@ struct dpcls_subtable {
 
 /* Initializes 'cls' as a classifier that initially contains no classification
  * rules. */
-static void
+void
 dpcls_init(struct dpcls *cls)
 {
     cmap_init(&cls->subtables_map);
@@ -6987,7 +6838,7 @@ dpcls_destroy_subtable(struct dpcls *cls, struct dpcls_subtable *subtable)
 /* Destroys 'cls'.  Rules within 'cls', if any, are not freed; this is the
  * caller's responsibility.
  * May only be called after all the readers have been terminated. */
-static void
+void
 dpcls_destroy(struct dpcls *cls)
 {
     if (cls) {
@@ -7039,7 +6890,7 @@ dpcls_find_subtable(struct dpcls *cls, const struct netdev_flow_key *mask)
 
 
 /* Periodically sort the dpcls subtable vectors according to hit counts */
-static void
+void
 dpcls_sort_subtable_vector(struct dpcls *cls)
 {
     struct pvector *pvec = &cls->subtables;
@@ -7096,7 +6947,7 @@ dp_netdev_pmd_try_optimize(struct dp_netdev_pmd_thread *pmd,
 }
 
 /* Insert 'rule' into 'cls'. */
-static void
+void
 dpcls_insert(struct dpcls *cls, struct dpcls_rule *rule,
              const struct netdev_flow_key *mask)
 {
@@ -7108,7 +6959,7 @@ dpcls_insert(struct dpcls *cls, struct dpcls_rule *rule,
 }
 
 /* Removes 'rule' from 'cls', also destructing the 'rule'. */
-static void
+void
 dpcls_remove(struct dpcls *cls, struct dpcls_rule *rule)
 {
     struct dpcls_subtable *subtable;
@@ -7153,7 +7004,7 @@ dpcls_rule_matches_key(const struct dpcls_rule *rule,
  * priorities, instead returning any rule which matches the flow.
  *
  * Returns true if all miniflows found a corresponding rule. */
-static bool
+bool
 dpcls_lookup(struct dpcls *cls, const struct netdev_flow_key *keys[],
              struct dpcls_rule **rules, const size_t cnt,
              int *num_lookups_p)
diff --git a/lib/dpif-netdev.h b/lib/dpif-netdev.h
index 6db6ed2e2..63e5fe923 100644
--- a/lib/dpif-netdev.h
+++ b/lib/dpif-netdev.h
@@ -24,16 +24,181 @@
 #include "openvswitch/types.h"
 #include "dp-packet.h"
 #include "packets.h"
+#include "flow.h"
+#include "cmap.h"
+#include "pvector.h"
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
+#define MAX_FLOW_MARK       (UINT32_MAX - 1)
+#define INVALID_FLOW_MARK   (UINT32_MAX)
+
 /* Enough headroom to add a vlan tag, plus an extra 2 bytes to allow IP
  * headers to be aligned on a 4-byte boundary.  */
-enum { DP_NETDEV_HEADROOM = 2 + VLAN_HEADER_LEN };
+enum {
+	DP_NETDEV_HEADROOM = 2 + VLAN_HEADER_LEN
+};
+
+/* Stores a miniflow with inline values */
+
+struct netdev_flow_key {
+	uint32_t hash; /* Hash function differs for different users. */
+	uint32_t len; /* Length of the following miniflow (incl. map). */
+	struct miniflow mf;
+	uint64_t buf[FLOW_MAX_PACKET_U64S];
+};
+
+struct dpcls {
+	struct cmap_node node; /* Within dp_netdev_pmd_thread.classifiers */
+	odp_port_t in_port;
+	struct cmap subtables_map;
+	struct pvector subtables;
+};
+
+/* A rule to be inserted to the classifier. */
+struct dpcls_rule {
+	struct cmap_node cmap_node; /* Within struct dpcls_subtable 'rules'. */
+	struct netdev_flow_key *mask; /* Subtable's mask. */
+	struct netdev_flow_key flow; /* Matching key. */
+	/* 'flow' must be the last field, additional space is allocated here. */
+};
+
+void dpcls_init(struct dpcls*);
+void dpcls_destroy(struct dpcls*);
+void dpcls_sort_subtable_vector(struct dpcls*);
+void dpcls_insert(struct dpcls*, struct dpcls_rule*,
+		const struct netdev_flow_key *mask);
+void dpcls_remove(struct dpcls*, struct dpcls_rule*);
+bool dpcls_lookup(struct dpcls *cls, const struct netdev_flow_key *keys[],
+		struct dpcls_rule **rules, size_t cnt, int *num_lookups_p);
+
+/* Contained by struct dp_netdev_flow's 'stats' member.  */
+struct dp_netdev_flow_stats {
+	atomic_llong used; /* Last used time, in monotonic msecs. */
+	atomic_ullong packet_count; /* Number of packets matched. */
+	atomic_ullong byte_count; /* Number of bytes matched. */
+	atomic_uint16_t tcp_flags; /* Bitwise-OR of seen tcp_flags values. */
+};
+
+/* A set of datapath actions within a "struct dp_netdev_flow".
+ *
+ *
+ * Thread-safety
+ * =============
+ *
+ * A struct dp_netdev_actions 'actions' is protected with RCU. */
+struct dp_netdev_actions {
+	/* These members are immutable: they do not change during the struct's
+	 * lifetime.  */
+	unsigned int size; /* Size of 'actions', in bytes. */
+	struct nlattr actions[]; /* Sequence of OVS_ACTION_ATTR_* attributes. */
+};
+
+struct packet_batch_per_flow;
+/* A flow in 'dp_netdev_pmd_thread's 'flow_table'.
+ *
+ *
+ * Thread-safety
+ * =============
+ *
+ * Except near the beginning or ending of its lifespan, rule 'rule' belongs to
+ * its pmd thread's classifier.  The text below calls this classifier 'cls'.
+ *
+ * Motivation
+ * ----------
+ *
+ * The thread safety rules described here for "struct dp_netdev_flow" are
+ * motivated by two goals:
+ *
+ *    - Prevent threads that read members of "struct dp_netdev_flow" from
+ *      reading bad data due to changes by some thread concurrently modifying
+ *      those members.
+ *
+ *    - Prevent two threads making changes to members of a given "struct
+ *      dp_netdev_flow" from interfering with each other.
+ *
+ *
+ * Rules
+ * -----
+ *
+ * A flow 'flow' may be accessed without a risk of being freed during an RCU
+ * grace period.  Code that needs to hold onto a flow for a while
+ * should try incrementing 'flow->ref_cnt' with dp_netdev_flow_ref().
+ *
+ * 'flow->ref_cnt' protects 'flow' from being freed.  It doesn't protect the
+ * flow from being deleted from 'cls' and it doesn't protect members of 'flow'
+ * from modification.
+ *
+ * Some members, marked 'const', are immutable.  Accessing other members
+ * requires synchronization, as noted in more detail below.
+ */
+struct dp_netdev_flow {
+	const struct flow flow; /* Unmasked flow that created this entry. */
+	/* Hash table index by unmasked flow. */
+	const struct cmap_node node; /* In owning dp_netdev_pmd_thread's */
+	/* 'flow_table'. */
+	const struct cmap_node mark_node; /* In owning flow_mark's mark_to_flow */
+	const ovs_u128 ufid; /* Unique flow identifier. */
+	const ovs_u128 mega_ufid; /* Unique mega flow identifier. */
+	const unsigned pmd_id; /* The 'core_id' of pmd thread owning this */
+	/* flow. */
+
+	/* Number of references.
+	 * The classifier owns one reference.
+	 * Any thread trying to keep a rule from being freed should hold its own
+	 * reference. */
+	struct ovs_refcount ref_cnt;
+
+	bool dead;
+	uint32_t mark; /* Unique flow mark assigned to a flow */
+
+	/* Statistics. */
+	struct dp_netdev_flow_stats stats;
+
+	/* Actions. */
+	OVSRCU_TYPE(struct dp_netdev_actions *)
+	actions;
+
+	/* While processing a group of input packets, the datapath uses the next
+	 * member to store a pointer to the output batch for the flow.  It is
+	 * reset after the batch has been sent out (See dp_netdev_queue_batches(),
+	 * packet_batch_per_flow_init() and packet_batch_per_flow_execute()). */
+	struct packet_batch_per_flow *batch;
+
+	/* Packet classification. */
+	struct dpcls_rule cr; /* In owning dp_netdev's 'cls'. */
+	/* 'cr' must be the last member. */
+};
+void
+dp_netdev_get_mega_ufid(const struct match *match, ovs_u128 *mega_ufid);
+struct dp_netdev_actions* dp_netdev_actions_create(const struct nlattr*,
+		size_t);
+void
+netdev_flow_key_init_masked(struct netdev_flow_key *dst,
+		const struct flow *flow, const struct netdev_flow_key *mask);
+struct dp_netdev_actions* dp_netdev_flow_get_actions(
+		const struct dp_netdev_flow*);
+void dp_netdev_actions_free(struct dp_netdev_actions*);
+
+void dp_netdev_flow_unref(struct dp_netdev_flow*);
+bool dp_netdev_flow_ref(struct dp_netdev_flow*);
+int dpif_netdev_flow_from_nlattrs(const struct nlattr*, uint32_t, struct flow*,
+		bool);
+
+void
+netdev_flow_mask_init(struct netdev_flow_key *mask, const struct match *match);
+
+struct packet_batch_per_flow {
+	unsigned int byte_count;
+	uint16_t tcp_flags;
+	struct dp_netdev_flow *flow;
+
+	struct dp_packet_batch array;
+};
 
-bool dpif_is_netdev(const struct dpif *);
+bool dpif_is_netdev(const struct dpif*);
 
 #define NR_QUEUE   1
 #define NR_PMD_THREADS 1
diff --git a/lib/hash.h b/lib/hash.h
index a642a1e97..b468a0347 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -192,7 +192,7 @@ static inline uint32_t hash_finish(uint64_t hash, uint64_t final)
 static inline uint32_t
 hash_words_inline(const uint32_t p_[], size_t n_words, uint32_t basis)
 {
-    const uint64_t *p = (const void *)p_;
+    const uint64_t *p = (const uint64_t *)(const void *)p_;
     uint64_t hash1 = basis;
     uint64_t hash2 = 0;
     uint64_t hash3 = n_words;
-- 
2.20.1

